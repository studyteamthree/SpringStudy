# 5. 서비스 추상화

## 5.1 사용자 레벨 관리 기능 추가

- 등록, 조회, 수정, 삭제 (CURD)의 기초적인 작업만 가능한 사용자 정보에 간단한 비즈니스 로직 추가가 필요

  ```
  사용자 레벨 관리 기능
   - 사용자 레벨 추가 : BASIC, SILVER, GOLD
   - 가입 직후 BASIC 레벨
   - 50회 이상 로그인시 SILVER 레벨
   - SILVER 레벨이면서 30회 이상 추천받을 시 GOLD
   - 레벨 변경은 일정한 주기로 일괄 변경되며, 조건에 충족하더라도 변경 작업 전에는 적용이 안된다.
  ```

  

  #### 5.1.1 필드 추가

  - User 객체에 사용자 레벨 관련 필드 추가

    ```java
    public class User {
    	String id;
    	String name;
    	String password;
    	Level level;
    	int login;
    	int recommend;
        
        //getter(),setter()
        //...
        
    }
    
    public enum Level {
    	BASIC(1), SILVER(2), GOLD(3);
    
    	private final int value;
    		
    	Level(int value) {
    		this.value = value;
    	}
    
    	public int intValue() {
    		return value;
    	}
    	
    	public static Level valueOf(int value) {
    		switch(value) {
    		case 1: return BASIC;
    		case 2: return SILVER;
    		case 3: return GOLD;
    		default: throw new AssertionError("Unknown value: " + value);
    		}
    	}
    }
    ```

    - Enum 장점

      > 직관적으로 사용 가능
      >
      > setLevel(-100) 과 같은 문제의 안전한 해결 방법

  - UserDaoTest

    ```java
    public class UserDaoTest 
    {
        ...
    	@Before
    	public void setUp() {
    		this.user1 = new User("gyumee", "�박성철", "springno1", Level.BASIC, 1, 0);
    		this.user2 = new User("leegw700", "이길원", "springno2", Level.SILVER, 55, 10);
    		this.user3 = new User("bumjin", "박범진", "springno3", Level.GOLD, 100, 40);
    	}
    }
    ```

    - User 필드가 변경되었으므로 UserDaoTest 또한 변경이 필요하다

      User 객체의 constructor 및 UserDaoTest의 다른 test 메소드들 또한 변경이 필요하다

  - UserDaoJdbc

    ```java
    public class UserDaoJdbc implements UserDao {
    	...
    	private RowMapper<User> userMapper = 
    		new RowMapper<User>() {
    				public User mapRow(ResultSet rs, int rowNum) throws SQLException {
    				User user = new User();
    				user.setId(rs.getString("id"));
    				user.setName(rs.getString("name"));
    				user.setPassword(rs.getString("password"));
    				user.setLevel(Level.valueOf(rs.getInt("level")));
    				user.setLogin(rs.getInt("lgoin"));
    				user.setRecommend(rs.getInt("recommend"));
    				return user;
    			}
    		};
    }
    ```

    - User 필드가 변경되었으므로 UserDaoJdbc 또한 수정해 줘야한다

    - 역시 TDD가  :sunny:최:smile:고:thumbsup::heavy_exclamation_mark:

      > ```
      > org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammaer [select * from users where id = ?]; nested exception is java.sql.SQLException: Clumn 'lgoin' not found
      > ```
      >
      > Test를 돌리면 발생하는 문제이다.
      >
      > JAVA 컴파일러 입장에서 SQL문은 단순한 문자열이므로 오타 등을 발견하기 쉽지 않다.
      >
      > Test를 하지 않고 배포됐다면 :zap:끔:disappointed_relieved:찍:bug:한 일이 벌어졌을지도 모른다.

  #### 5.1.2 사용자 수정 기능 추가

  - 기본키인 id를 제외한 나머지 필드는 여러 번 수정 될 수 있을거 같당. 수정할 수 있는 기능을 추가해보자.

  - 수정 기능 테스트 추가 (~~역시 TDD가  :sunny:최:smile:고:thumbsup::heavy_exclamation_mark:~~)

    ```java
    	@Test
    	public void update() {
    		dao.deleteAll();
    		
    		dao.add(user1);		// 수정할 사용자
    		dao.add(user2);		// 수정하지 않을 사용자
    		
    		user1.setName("오민규");
    		user1.setPassword("springno6");
    		user1.setLevel(Level.GOLD);
    		user1.setLogin(1000);
    		user1.setRecommend(999);
    		
    		dao.update(user1);
    		
    		User user1update = dao.get(user1.getId());
    		checkSameUser(user1, user1update);
    		User user2same = dao.get(user2.getId());
    		checkSameUser(user2, user2same);
    	}
    ```

  - UserDao, UserDaoJdbc 수정

    ```
    public interface UserDao {
    	...
    	void update(User user);
    }
    ```

    ```
    	public void update(User user) {
    		this.jdbcTemplate.update(
    				"update users set name = ?, password = ?, level = ?, login = ?, " +	"recommend = ? where id = ? ", user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend(), user.getId());		
    	}
    ```

    - Test를 먼저 만들면, 아직 준비되지 않은 기능을 사용하기 때문에 에러가 발생할 것이고, 대부분의 IDE는 이런 에러를 표시해주며 동시에 에러를 수정할 수 있는 자동고침 기능을 제공하기 때문에 편리하다 (~~역시 TDD가  :sunny:최:smile:고:thumbsup::heavy_exclamation_mark:~~). 반대로 기능을 먼저 구현한 후 테스트를 작성하는 경우에는 자동 완성을 이용하면 편리하다.

  - 수정 테스트 보완

    - 개발자들에게 가장 많은 실수를 유발시키는 부분 중 하나가 SQL문이므로 좀다 강한 테스트를 해봐야 할것 같다. 수정 테스트의 경우는 **UPDATE**문은 where가 없어도 문법적으로 문제가 없지만, 실제로는 원치 않는 정보 까지 변경되는 문제가 발생한다. 어떻게 검증할까?
    - 첫번 째 방법은 update()의 리턴 값을 확인하는 것이다. **UPDATE**,**DELETE**같은 테이블 내용에 영향을 주는 SQL들은 영향을 받은 row의 수를 리턴하므로 1을 리턴하는지 확인하는 테스트 코드를 작성하여 해결할 수 있다.
    - _(적용)_두번 째 방법은 사용자를 두명 등록하여 하나만 수정한 뒤 두 사용자의 정보를 확인해보면 된다. 이일민님께서는 이 방법을 선택하셧고 Test 코드에 user를 2명 등록 후 하나만 변경한 것은 이러한 이유 때문이다.

  #### 5.1.3 UserService.upgradeLevels()

  

# 

## 5.2 
