### 스프링의 IoC

#### 오브젝트 팩토리를 이용한 스프링 IoC (Application Context)

- 스프링에서는 스프링이 직접 제어권을 가지고 만들어서 관계를 부여하는 객체들을 `Bean`이라고 부른다. 
- 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(bean factory) 라고 부른다. 일반적으로는 좀 더 확장한 애플리케이션 컨텍스트(application Context)를 주로 사용한다.
- Application Context는 그 자체로는 애플리케이션 로직을 담당하지 않지만 IoC방식을 이용함으로써 별도의 정보를 참고해서 빈의 생성과 관계설정 등의 제어 작업을 한다.
  - @Configuration : Application Context가 사용할 설정 정보라는 표시이다.
  - @Bean : 오브젝트 생성을 담당하는 IoC용 메소드라는 표시이다.
    - 우리는 수업을 진행하며 코드에 표시하는 위의 두 Annotation을 applicationContext.xml이라는 파일에 명시해주고, DispatcherServlet이나 ApplicationContextListener가 이 정보를 읽어서 자동으로 빈들을 컨텍스트에 생성해두도록 했다.
- Application Context는 자바의 `ApplicationContext`  라는 이름의 오브젝트이다. ApplicationContext를 구현한 클래스는 여러가지가 있으며, 위의 두 Annotation으로 설정한 클래스와 메소드의 빈 정보를 읽기 위해서는 `AnnotationConfigApplicationContext` 를 이용하면 된다.



- getBean() 메소드는 컨텍스트가 관리하는 오브젝트를 요청할 수 있다. 기본적으로 `Object` 타입으로 리턴해서 아래와 같이 다시 캐스팅 해줘야 한다. 하지만 우리의 예제 속에서는 내부 파라미터로 해주는 오버로딩 된 메소드를 사용한다.

  ```java
  //원래 설정
  UserDao dao = (UserDao)context.getBean("userDao");
  
  //내부 파라미터 설정
  UserDao dao = context.getBean("userDao", UserDao.class);
  
  ```

- 오브젝트 팩토리로서 Application Context를 사용하는 장점은 아래와 같다.

  - 클라이언트는 구체적인 팩토리 메소드를 알 필요가 없다.
  - Application Context는 종합 IoC 서비스를 제공해준다.
  - Application Context는 빈을 **검색**하는 다양한 방법을 제공한다.

- 스프링 IoC의 용어 정리

  - **빈**
    빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다. 주의할 점은 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 사실이다. 그 중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
  - **빈 팩토리**
    스프링의 IoC를 담당하는 핵심 컨테이너를 말한다. 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당한다.
  - **애플리케이션 컨텍스트**
    빈 팩토리를 확장한 IoC.컨테이너다. 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다. 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용된다.
  - **설정정보/설정 메타정보**
    스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다. IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.
  - **컨테이너 또는 IoC 컨테이너**
    IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다. 그냥 컨테이너 또는 스프링 컨테이너라고 할 때는 애플리케이션 컨텍스트를 가리키는 것이라고 보면 된다.

> **오브젝트의 동일성과 동등성**
>
> 자바에서는 두개의 오브젝트가 완전히 같은 오브젝트라고 말하는 것을 `동일성` , 동일한 정보를 담고 있는 오브젝트이면 `동등성` 이 충족한다고 한다.
>
> 동일성은 `==` 연산자로, 동등성은 `equals()` 메소드를 이용해 비교한다.

- 위의 내용은 수업을 통해 확인했으며 equals()를 통해 동일성을 검증하기 위해서는 `hashCode()` 를 같이 오버라이드 해서 해시코드 값도 동일하게 해주어야 한다.



### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

- 스프링의 Application Context와 기존의 오브젝트 팩토리와의 다른 점 중의 하나는 스프링은 내부 빈 오브젝트를 모두 싱글톤으로 만든다. 결국 싱글톤을 저장하고 관리하는 `싱글톤 레지스트리`  이기도 하다.

#### 싱글톤 패턴의 한계

- 일반적인 싱글톤 구현 방식에는 다음과 같은 한계가 있다.
  - private 생성자이므로 상속 불가
  - 테스트하기 힘들다.
  - 서버환경에서 싱글톤이 하나만 만들어지는 것을 보장하지 못한다. (서버 환경에서는 여러 jvm이나 class loader가 올라갈 수 있으므로)
  - 싱글톤 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
    - 어디에서든 접근할 수 있는 static 이므로

#### 싱글톤 레지스트리

- 스프링은 싱글톤으로 오브젝트를 관리하는 것을 적극적으로 지지한다. 하지만 자바의 기본적인 싱글톤 패턴은 위와 같은 단점이 있기 때문에 **스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 `싱글톤 레지스트리` 이다.
- 이는 private 생성자와 static 메소드를 활용하는 것이 아니라 일반적인 자바 클래스를 싱글톤으로 활용할 수 있게 한다.

#### 싱글톤과 오브젝트의 한계

- 싱글톤은 무상태(stateless) 여야 한다.
  - 멀티 스레드 환경에서 여러 스레드가 싱글톤으로 구현된 하나의 객체에 접근할 수 있기 때문에 싱글톤 오브젝트는 자신의 상태를 저장하거나 가지고 있어서는 안된다.
  - 따라서 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나 파라미터로 주고 받아야 한다.
  - 하지만 자신이 사용하려는 다른 싱글톤 빈을 저장하려는 용도라면 사용해도 된다.



#### 스프링 빈의 스코프

- 빈이 생성되고, 적용되는 범위를 빈의 싱글톤 Scope라고 한다.
- 우리는 웹 프로그래밍을 진행하며 `request` , `session`, `page`, `application` 이 네가지의 스코프를 보았다. 스프링에서는 각각 하나의 컨텍스트로서 관리한다.

### 의존관계 주입 (DI)

IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어이기 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.

그래서 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 `의존관계 주입(Dependency Injection)`이라는, 좀 더 의도가 명확한 이름을 사용하기 시작했다.

스프링이 다른 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다.

**DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 다른 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이다.**

#### 런타임 의존관계 설정

모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계 말고, 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 설계 시점의 의존관계가 실체화된 것이다.

런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 `의존 오브젝트`라고 한다.

**의존관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업을 말한다.**

의존관계 주입이란 다음의 세 가지 조건을 충족하는 작업을 말한다.

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
- 이존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다. 스프링의 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재이다.

DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어맞는다.

#### 의존관계 검색과 주입

스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다.

의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 `의존관계 검색`이라고 불리는 것도 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.

**의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.**

스프링의 IoC와 DI 컨테이너를 적용했다고 하더라도 애플리케이션의 기동 시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다. static 메소드인 main()에서는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다.

의존관계 검색(DL)과 의존관계 주입을 적용할 때 발견할 수 있는 중요한 차이점이 하나 있다. **의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다.**

반면에 의존관계 주입에서는 오브젝트 사이에 DI가 적용되려면 반드시 두 오브젝트 모두 컨테이너가 만드는 빈 오브젝트여야 한다.