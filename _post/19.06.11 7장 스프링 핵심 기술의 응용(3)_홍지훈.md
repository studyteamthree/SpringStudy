# 7장 스프링 핵심 기술의 응용

## 7.6 스프링 3.1의 DI
8년이 지난 지금까지 스프링은 여러 변화를 거치면서도 완벽에 가까운 호환성을 유지하고있다.
이것은 스프링 프레임워크가 근본적으로 지지하는 객체지향의 특징과 장점을 극대화하는 유연성과 확장성을
고수한것, 그것을 위해 DI패턴을 이용한 원칙을 충실하게 따라 만들어 졌기 때문이라고 할 수 있다.


<br>


### 자바 언어의 변화와 스프링
스프링이 제공하는 근본적인 DI의 원리는 변하지 않았지만 Java언어에는 적지 않은 변화가 있었다.
이에따라 변하게된 DI의 사용방식의 변화를 정리해봤다.

<br>

#### Annotation의 메타정보 활용
자바5에서 나온 Annotation의 등장은 Application의 핵심 로직을 담은 자바코드와 이를 지원하는
IoC 방식의 프레임워크, 프레임워크가 참조하는 메타정보라는 세가지의 구성방식과 어우러져 긍정적으로 작용한다.

> DI 메타정보로 활용되던 XML은 XML자체의 한계점을 맞은 상황에서 Annotation의 등장은 메타정보를 부여하고
추출해 내는데 유리하다는 장점과 작성시의 수월함으로 인해 점차 많은 영역에서 대체되었다.

<br>

#### 정책과 관례를 이용한 프로그래밍
Annotation을 이용한 프로그래밍 방식은 동작하는 내용을 기술하는 것이 아닌 규칙과 관례를 이용한
프로그래밍 스타일을 적극적으로 포용하게 만들었다.

예를들어 스프링의 XML을 작성할때도 미리 정해진 규칙이나 관례를 이용해 작성하여 코드의 양을 최소화 시켰고
Annotation은 관례를 부여해 명시적인 설정을 최대한 배제하는식으로 작성한것이다.

대표적으로 `@Transactional` 은 스프링에서 정해진 4단계의 관례화된 정책을 통해 우선순위같은 생략된 정보도 표현할 수 있다.

<br>

### 7.6.1 자바 코드를 이용한 빈 설정 (Java Config)
> 7.6.1절에서는 강의내용에서 진행했던 XML설정으로 이루어진 기존 코드를 Java Config로 리팩토링하는 과정으로 구성되어있다.

Java Config 구성으로의 전환을 위한 첫번째 단계로는 Bean이 정의되어있는 ApplicationContext.xml을 class로 전환하는 작업을 진행한다.

<br>

#### 컨텍스트 변경
책의 예제에서는 Test코드에서 참조하는 Bean객체들이 위치한
```java
@ContextConfiguration(location="/test-applicationContext.xml")
```
가 클래스 정보를 참조하도록 바꿨다.

<br>

#### `<context:annotation-config />` 제거
초기화를 수행하는 메서드에 붙이는 `@PostConstruct` 의 사용이 없어진다. XML에서 JavaCode로 대체되는 것은
`@Configuration` 이 붙은 자바클래스를 DI정보로 사용하기 때문에 더이상 필요 없어지는것이다.

<br>

#### `<bean>`의 전환
Method를 이용해 bean 오브젝트의 생성과 의존관계 주입을 자바코드로 작성해준다.

이때 주의할점은 접근 제한자를 `public`으로 만드는것과 리턴타입을 신중하게 결정해야 한다.

빈 오브젝트의 클래스를 받아 사용하고 프로퍼티가 있다면 변수로 받아 사용한다.

책에서는 DataSource 빈의 예시를 들며 XML 프로퍼티 설정시 스프링 컨테이너에서 형변환이 이루어지는것을 보여주며 **자바코드에서는 프로퍼티 타입에 맞는 값을 넣어야 한다고 강조했다.**

또한 XML에 정의된 빈을 자바코드로 가져오기 위해서는 `@Autowired` 어노테이션을 사용하여 컨테이너에서 주입해야한다는점도 언급했다. (SqlSerivce)

<br>


#### 전용태그의 전환 666p
앞서 진행한 <bean>을 자바코드로 전환시키는 과정을 수행한뒤 남은 **전용태그를 어떻게 자바코드로 전환시키는지에 관한 내용** 이다.

`<jdbc:embeded-database>`는 내장형 DB에 관한 전용태그로 DataSource을 빈 타입으로 갖는다.

jdbc:embeded-database는 스프링이 제공하는 내장형 DB EmbeddedDatabaseBuilder를 이용해 @Bean 메소드로 전환하였지만

`<tx:annotation-driven />` 은 4가지 클래스를 사용하는 문제점을 예시로 들며 **스프링 3.1의 로우 레벨에서의 빈 등록을 위한 Annotation도 제공한다는 것을 언급했다.**

<br>

### 7.6.2 빈 스캐닝과 자동와이어링 672p

#### `@Autowired` 를 이용한 자동와이어링
7.6.1 절에서 진행했던 자바코드로의 전환에서 빈 오브젝트를 주입하는 코드를 `@Autowired` 를 이용해 의존관계에 있는 객체들을 참조하여 주입할 수 있도록 만드는 과정이다.

`✔️ 이때 주의할점은 @Autowired를 이용해 주입할 객체를 찾는 과정은 파라미터 타입을 보고 찾는다는 점이다.`
`✔️ 만약 두개 이상이 나온다면 그중에서 프로퍼티와 동일한 이름의 빈을 찾는다.`

<br>

#### `@Component` 를 이용한 자동 빈 등록
`@Component` 는 클래스에 부여되는 Annotation으로 빈스캐너를 통해 자동으로 클래스가 빈이 될 수 있는 **후보** 가 된다.

그렇기때문에 책에서는 테스트 환경의 Context인 `TestApplicationContext.class`에서 `@ComponentScan`을 통해

@Component 가 등록된 클래스를 찾기위한 특정 패키지 위치를 명시해줬다. (검색에 부담을 줄이기 위함)

스캐닝을 통해 @Component 가 붙은 클래스를 발견하게되면 새로운 빈을 자동으로 추가하는 과정이 이루어지는데

이 과정에서 빈의 클래스는 @Component가 붙은 클래스를 따라가고 빈의 아이디는 클래스이름의 첫글자를 소문자로 바꿔 만들어지게 된다.

`❓ 그렇다면 @Service 와 @Repository는 어떻게 @ComponentScan을 거쳐 빈으로 등록될까?`

<br>

### 7.6.3 컨텍스트 분리와 @Import
테스트 환경과 실제 Applicaton 환경의 분리를 위해 성격이 다른 DI정보를 분리하는 과정이다

<br>

#### 테스트용 컨텍스트 분리 --- 생략

#### @Import
앞서 진행한 분리에서는 성격에 따라 빈 설정정보를 나눠서 구성했고 SqlSerivce를 독립적인 모듈로 취급하여

SQL서비스에 관한 빈 객체를 Appcontext에서 @Import 로 받아 내는 과정에 대한 내용이다.

<br>

### 7.6.4 프로파일 688p
서비스 추상화를 진행하며 메일 송신 테스트를 위해 만든 DummyMailSender는 현재 테스트 환경에서만 사용되어

실제 운영하는 시스템에서는 메일기능을 가진 MailSender타입의 빈이 존재하지않는다.

이 점을 문제점으로 얘기하며 TestContext와 실제 ApplicationContext의 환경에서 서로 다른 빈설정을 갖고 동작하기위한 과정을 설명하는 내용이다.

<br>

#### @Profile과 @ActiveProfiles
스프링 3.1은 환경에 따라 빈 설정정보를 바꿔야할 경우 달라지는 내용을 프로파일로 정의하여 실행시점에

어떤 프로파일의 빈 설정을 사용할지 지정하는 방법을 사용한다.

프로파일은 설정 클래스 단위로 지정되며 @Proifle 어노테이션을 사용해 프로파일 이름을 넣어준다.

책에서는 빈설정정보를 포함하고있는 TestAppContext에 @Profile("test")를 넣고

테스트를 진행하는 클래스들에서 @ActiveProfile("test")를 통해 test 프로파일을 활성프로파일로 사용하게 하였다.

<br>

#### 컨테이너의 빈 등록정보 확인 --- 생략
#### 중첩 클래스를 이용한 프로파일 적용 --- 생략

<br>

### 7.6.5 프로퍼티 소스
컨테이너가 프로퍼티 값을 가져오는 대상을 프로퍼티 소스라고 한다. @PropertySource 어노테이션을 이용해 컨테이너가 가져올

`📝example.properties`파일의 위치를 명시하여 사용한다. 프로퍼티 값은 컨테이너가 관리하는 Enviroment 타입의 환경 오브젝트를 통해 저장되는데,

@Autowired 를 통해 필드로 주입받아 사용하며 주입받은 Enviroment 오브젝트의 getProperty('key')를 이용해 값을 가져와 사용하는 방식이다.

**`✔️ 리턴되는 값의 타입에 주의하자 XML에서 리플렉션 API를 통해 형변환을 해줬던것과는 달리 직접 형변환을 진행해야 한다.`**

<br>

#### PropertySourcePlaceholderConfigurer
Enviroment 오브젝트 대신 프로퍼티 값을 직접 DI받는 방법에 대해 설명하는 내용이다.

빈 오브젝트가 아닌 객체를 @Value 어노테이션으로 받아 사용하는데 이름 그대로 값을 주입받는 용도로 사용된다.

이를 위해 PropertySourcePlaceholderConfigurer 를 생성하는 즉, 후처리기로 사용되는 빈을 정의해주는 메소드를 static으로 선언한다.
```java
@Bean
public static PropertySourcePlaceholderConfigurer placeholderConfigurer(){
	return new PropertySourcePlaceholderConfigurer();
}
```

@Value 를 사용한 방식은 타입변환이 필요한 프로퍼티를 스프링이 알아서 해준다는 장점이 있다.

<br>

### 7.6.6 빈 설정의 재사용과 @Enable*
앞단에서 분리한 SqlSerivce를 재사용 가능한 독립적인 모듀로 만들기 위해 

#### @Enable* 어노테이션
