# 9. 스프링 프로젝트 시작하기 (2)



## 9.3 어플리케이션 아키텍처

- 스프링 웹 어플리케이션의 아키텍처를 소개한다.

  #### 9.3.1 계층형 아키텍처

  - 아키텍처와 SoC

    - 지금까지 오브젝트 레벨에서 인터페이스를 이용해 유연한 경계를 만들어 분리하거나 모아주었다. 이런 원리를 아키텍처 레벨의 좀더 큰 단위에서도 적용한다.
    - 애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들 끼리 묶는다. 
    - a.k.a 멀티 티어 아키텍처

  - 3계층 아키텍처와 수직 계층

    - 웹 기반 엔터프라이즈 애플리케이션은 일반적으로 3개의 계층을 갖는 아키텍처를 구성한다. (무조건 그런건 아니지만 다른 구분 방법 또한 이 3계층의 분류는 유효하다)

    ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.1_3layer_architecture.PNG)

    - 데이터 액세스 계층 (a.k.a DAO 계층)

      - DB 및 ERP, 레거시 시스템 등에 접근 (때문에 EIS 계층이라고도 함)

      - 대게 DB 이용이 주된 책임이다

      - 다시 세분화하여 수직적인 계층으로 구분된다.

        ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.1_VerticalArchInDataAccesslayer.PNG)

        ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.1_AbstractLayerForIntegrateSevices.PNG)

        위의 계층에서 새로운 계층을 추가하면 개발자의 애플리케이션 코드에 영향이 많기 때문에 신중하게 합시다.!

        > 새로운 계층 추가가 부담스럽다면 공통 기능을 분리해 API형태로 제공하는 것도 좋은 방법!

    - 서비스 계층

      - 구조는 가장 단순하며, 잘 만들어진 스프링 애플리케이션에서 서비스 계층은 POJO로 작성된다.

      - DAO 계층을 호출하고 이를 활용해서 만든다.

      - 서비스 계층과 기반 서비스 계층은 혼동되기 쉬으므로 주의하자

        ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.1_ServiceLayerNBase.PNG)

    - 프리젠테이션 계층

      - 가장 복잡한 계층이며, 끊임없이 발전하기 때문에 다양한 기술과 프레임워크의 조합이 있으므로 이 중 선택하는 일은 간단하지 않다.

        > 웹 어플리케이션은 HTTP 프로토콜을 사용하는 서블릿으로 수렴되는 추세다.

      - 클아이언트까지 그 범위가 확대 되기도 한다.

  - 계층형 아키텍처 설계의 원칙

    - 객체 지향 설계의 원칙과 동일하게 계층별로 응집도가 높으면서 다른 계층과 낮은 결합도를 유지해야 한다.
    - 각 계층은 자신의 계층의 책임에만 충실해야 한다.
    - 예를 보자
    
    ```java
    public ResultSet findUserByName() throws SQLException;
    ```
    
    > -> JDBC 기술이 노출되므로 안좋다.
    
    ```
    HttpServletRequest나 HttpServletREsponse를 서비스 계층 인터페이스의 파라미터로 사용하는 행위
    ```
    
    > 이 또한 프레젠 테이션 계층의 기술이 노출되므로 종속되고 코드의 재사용이 불가능해진다.
  
  #### 9.3.2 애플리케이션 정보 아키텍처
  
  ```
  앤터프라이즈 시스템은 독립 애플리케이션과 달리 사용자의 요청을 처리하는 동안만 상태를 유지하며 긴 상태정보는 DB나 EIS 백엔드 시스템에 저장한다. 이렇게 애플리케이션을 사이에 두고 흐르는 정보를 어떤 식으로 다룰지에 따라 아키텍처를 다르게 적용할 수 있다. 크게 정보들을 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우 두 가지로 나눌 수 있다.
  ```
  
  - 데이터 중심 아키텍처는 정보들을 단순히 값 또는 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조이다. 비즈니스 로직을 DB내부 저장 프로시저 또는 SQL에 담겨 있는 경우가 많다.
  
  - 핵심 비즈니스 로직을 두는 위치에 따라서 DB에 무게를 두는 구조, 서비스 계층에 무게를 두는 구조로 구분할 수 있다.
  
  - DB/SQL 중심의 로직 구현 방식
  
    - 비즈니스 로직을 DB에서 구현한다.
  
      ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.2_DBbaseArchi.PNG)
  
      > 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사람의 아이디, 비번, 가입일자를 보여줘야 하는 작업을 예로 들어보자.
      >
      > 검색 조건도 SQL로 만들어지며 표현 방식도 SQL로 나타낸다. 가입일자에서 연도만 빼내야 한다면 SQL 날짜 처리 펑션을 사용하면 된다.
      >
      > 자바 코드는 단지 DB와 화면을 연결해주는 인터페이스정도로만 이용된다.
  
    - 장점
  
      > 개발하기 쉽다. (적어도 처음에는)
      >
      > 코드 생성기 등을 이용해 자동화에 유리
  
    - 단점
  
      > 중복제거가 쉽지 않다.
      >
      > 객체 지향의 장점을 별로 활용하지 못한다.
      >
      > 확장성은 점점 떨어져간다.
      >
      > DB가 힘들어한다
      >
      > 정치적이거나 현실적인 문제로 인해 어쩔 수 없이 이런 방식으로 했을 때 마음이 아프다.
      >
      > 스프링의 장점을 제대로 누릴 수 있는 기회가 없다.
      >
      > 요정도만 적혀있지만 더 많을 것 같다.
  
  - 거대한 서비스 계층 방식
  
    - DB에서 가져온 데이터가 정보의 중심이긴 하지만 위에  DB중심 구현방식의 단점을 피한다.
  
    - DB가 힘들어하지 않도록 저장 프로시저를 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하는 것
  
      ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.2_LageServiceLayerArchi.PNG)
  
    - 장점
  
      > 자바 언어의 장점을 활용할 수 있다.!
      >
      > 단위 업무별 개발이 가능하므로 초기 개발 속도도 빠른편이다.
      >
      > DB가 덜 힘들어 한다.
  
    - 단점
  
      > 위의 모든 장점들이 그저 DB 중심의 방식보다 조금 나은 수준이란 점
      >
      > 개발 초창기에만 위 장점들을 얻을 수 있다는 점
      >
      > 오히려 DB 중심 방식보다 어렵고 개발자 개인의 습관이나 실력에 따라 다른 코드들이 나온다는 점
      >
      > 계층 사이의 결합도가 높도 응집도는 떨어지는 법
      >
      > 중복이 많아 지기 쉽고 또 기타 등등
  
  #### 9.3.3 오브젝트 중심 아키텍처
  
  - DB의 엔티티 구조와 유사한 오브젝트를 만들어 두고 오브젝트 구조 안에 정보를 담아서 계층 사이에 전달하게 만드는 것
  
  - 데이터와 오브젝트
  
    - 1:N 관계를 갖는 Category와 Product 엔티티를 가정하자
  
      > Category
      > | 필드명      | 타입         | 설정        |
      | ----------- | ------------ | ----------- |
      | CategoryId  | int          | Primary Key |
      | Description | varchar(100) |             |
  
      > Product
      > | 필드명     | 타입         | 설정                   |
      | ---------- | ------------ | ---------------------- |
  | ProductId  | int          | Primary Key            |
      | Name       | varchar(100) |                        |
      | Price      | int          |                        |
      | CategoryId | int          | Foreign Key (Category) |
      
    - 모든 카테고리와 상품 정보를 화면에 출력하자
    
      ```sql
      SELECT c.categoryid, c.description, p.productid, p.name, p.price
      FROM product p JOIN category c on p.categoryid = c.categoryid
      ```
    
      이렇게 가져온 정보를 List<Map<String, Object>> 타입으로 보내자.
    
    - 타입만 보고 담긴 내용을 정확히 알 수 없으며, SQL이나 필드의 개수 순서가 바뀌면 서비스 계층, 프레젠테이션 계층 코드 모두 변해야한다. (대충 이러저러해서 안좋다는 뜻이다.)
    
    - 오브젝트 방식으로 하기 위해 도메인 구조를 반영하여 오브젝트를 만들자
    
      ```java
      public class Category{
      	int categoryid;
          String description;
          Set<Product> products;
          
          //접근자, 수정자
      }
      
      public class Product{
          int productid;
          String name;
          int price;
          Category category;
          
          //접근자, 수정자
      }
      ```
    
      특정 SQL에 대응되게 만든 MAP 오브젝트와 달리 어플리 케이션 어디도 사용될 수 있는 일관된 형식의 도메인 정보를 갖고 있는다.
    
    - 데이터 중심보다 좋은점
    
      > 