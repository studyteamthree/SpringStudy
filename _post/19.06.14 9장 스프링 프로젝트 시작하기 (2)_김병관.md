# 9. 스프링 프로젝트 시작하기 (2)



## 9.3 어플리케이션 아키텍처

- 스프링 웹 어플리케이션의 아키텍처를 소개한다.

  #### 9.3.1 계층형 아키텍처

  - 아키텍처와 SoC

    - 지금까지 오브젝트 레벨에서 인터페이스를 이용해 유연한 경계를 만들어 분리하거나 모아주었다. 이런 원리를 아키텍처 레벨의 좀더 큰 단위에서도 적용한다.
    - 애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들 끼리 묶는다. 
    - a.k.a 멀티 티어 아키텍처

  - 3계층 아키텍처와 수직 계층

    - 웹 기반 엔터프라이즈 애플리케이션은 일반적으로 3개의 계층을 갖는 아키텍처를 구성한다. (무조건 그런건 아니지만 다른 구분 방법 또한 이 3계층의 분류는 유효하다)

    ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.1_3layer_architecture.PNG)

    - 데이터 액세스 계층 (a.k.a DAO 계층)

      - DB 및 ERP, 레거시 시스템 등에 접근 (때문에 EIS 계층이라고도 함)

      - 대게 DB 이용이 주된 책임이다

      - 다시 세분화하여 수직적인 계층으로 구분된다.

        ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.1_VerticalArchInDataAccesslayer.PNG)

        ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.1_AbstractLayerForIntegrateSevices.PNG)

        위의 계층에서 새로운 계층을 추가하면 개발자의 애플리케이션 코드에 영향이 많기 때문에 신중하게 합시다.!

        > 새로운 계층 추가가 부담스럽다면 공통 기능을 분리해 API형태로 제공하는 것도 좋은 방법!

    - 서비스 계층

      - 구조는 가장 단순하며, 잘 만들어진 스프링 애플리케이션에서 서비스 계층은 POJO로 작성된다.

      - DAO 계층을 호출하고 이를 활용해서 만든다.

      - 서비스 계층과 기반 서비스 계층은 혼동되기 쉬으므로 주의하자

        ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.1_ServiceLayerNBase.PNG)

    - 프리젠테이션 계층

      - 가장 복잡한 계층이며, 끊임없이 발전하기 때문에 다양한 기술과 프레임워크의 조합이 있으므로 이 중 선택하는 일은 간단하지 않다.

        > 웹 어플리케이션은 HTTP 프로토콜을 사용하는 서블릿으로 수렴되는 추세다.

      - 클아이언트까지 그 범위가 확대 되기도 한다.

  - 계층형 아키텍처 설계의 원칙

    - 객체 지향 설계의 원칙과 동일하게 계층별로 응집도가 높으면서 다른 계층과 낮은 결합도를 유지해야 한다.
    - 각 계층은 자신의 계층의 책임에만 충실해야 한다.
    - 예를 보자

    ```java
    public ResultSet findUserByName() throws SQLException;
    ```

    > -> JDBC 기술이 노출되므로 안좋다.

    ```
    HttpServletRequest나 HttpServletREsponse를 서비스 계층 인터페이스의 파라미터로 사용하는 행위
    ```

    > 이 또한 프레젠 테이션 계층의 기술이 노출되므로 종속되고 코드의 재사용이 불가능해진다.

  #### 9.3.2 애플리케이션 정보 아키텍처

  ```
  앤터프라이즈 시스템은 독립 애플리케이션과 달리 사용자의 요청을 처리하는 동안만 상태를 유지하며 긴 상태정보는 DB나 EIS 백엔드 시스템에 저장한다. 이렇게 애플리케이션을 사이에 두고 흐르는 정보를 어떤 식으로 다룰지에 따라 아키텍처를 다르게 적용할 수 있다. 크게 정보들을 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우 두 가지로 나눌 수 있다.
  ```

  - 데이터 중심 아키텍처는 정보들을 단순히 값 또는 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조이다. 비즈니스 로직을 DB내부 저장 프로시저 또는 SQL에 담겨 있는 경우가 많다.

  - 핵심 비즈니스 로직을 두는 위치에 따라서 DB에 무게를 두는 구조, 서비스 계층에 무게를 두는 구조로 구분할 수 있다.

  - DB/SQL 중심의 로직 구현 방식

    - 비즈니스 로직을 DB에서 구현한다.

      ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.2_DBbaseArchi.PNG)

      > 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사람의 아이디, 비번, 가입일자를 보여줘야 하는 작업을 예로 들어보자.
      >
      > 검색 조건도 SQL로 만들어지며 표현 방식도 SQL로 나타낸다. 가입일자에서 연도만 빼내야 한다면 SQL 날짜 처리 펑션을 사용하면 된다.
      >
      > 자바 코드는 단지 DB와 화면을 연결해주는 인터페이스정도로만 이용된다.

    - 장점

      > 개발하기 쉽다. (적어도 처음에는)
      >
      > 코드 생성기 등을 이용해 자동화에 유리

    - 단점

      > 중복제거가 쉽지 않다.
      >
      > 객체 지향의 장점을 별로 활용하지 못한다.
      >
      > 확장성은 점점 떨어져간다.
      >
      > DB가 힘들어한다
      >
      > 정치적이거나 현실적인 문제로 인해 어쩔 수 없이 이런 방식으로 했을 때 마음이 아프다.
      >
      > 스프링의 장점을 제대로 누릴 수 있는 기회가 없다.
      >
      > 요정도만 적혀있지만 더 많을 것 같다.

  - 거대한 서비스 계층 방식

    - DB에서 가져온 데이터가 정보의 중심이긴 하지만 위에  DB중심 구현방식의 단점을 피한다.

    - DB가 힘들어하지 않도록 저장 프로시저를 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하는 것

      ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.2_LageServiceLayerArchi.PNG)

    - 장점

      > 자바 언어의 장점을 활용할 수 있다.!
      >
      > 단위 업무별 개발이 가능하므로 초기 개발 속도도 빠른편이다.
      >
      > DB가 덜 힘들어 한다.

    - 단점

      > 위의 모든 장점들이 그저 DB 중심의 방식보다 조금 나은 수준이란 점
      >
      > 개발 초창기에만 위 장점들을 얻을 수 있다는 점
      >
      > 오히려 DB 중심 방식보다 어렵고 개발자 개인의 습관이나 실력에 따라 다른 코드들이 나온다는 점
      >
      > 계층 사이의 결합도가 높도 응집도는 떨어지는 법
      >
      > 중복이 많아 지기 쉽고 또 기타 등등

  #### 9.3.3 오브젝트 중심 아키텍처

  - DB의 엔티티 구조와 유사한 오브젝트를 만들어 두고 오브젝트 구조 안에 정보를 담아서 계층 사이에 전달하게 만드는 것

  - 데이터와 오브젝트

    - 1:N 관계를 갖는 Category와 Product 엔티티를 가정하자

      > Category

      | 필드명      | 타입         | 설정        |
      | ----------- | ------------ | ----------- |
      | CategoryId  | int          | Primary Key |
      | Description | varchar(100) |             |

      > Product

      | 필드명     | 타입         | 설정                   |
      | ---------- | ------------ | ---------------------- |
      | ProductId  | int          | Primary Key            |
      | Name       | varchar(100) |                        |
      | Price      | int          |                        |
      | CategoryId | int          | Foreign Key (Category) |

    - 모든 카테고리와 상품 정보를 화면에 출력하자

      ```sql
      SELECT c.categoryid, c.description, p.productid, p.name, p.price
      FROM product p JOIN category c on p.categoryid = c.categoryid
      ```

      이렇게 가져온 정보를 List<Map<String, Object>> 타입으로 보내자.

    - 타입만 보고 담긴 내용을 정확히 알 수 없으며, SQL이나 필드의 개수 순서가 바뀌면 서비스 계층, 프레젠테이션 계층 코드 모두 변해야한다. (대충 이러저러해서 안좋다는 뜻이다.)

    - 오브젝트 방식으로 하기 위해 도메인 구조를 반영하여 오브젝트를 만들자

      ```java
      public class Category{
      	int categoryid;
          String description;
          Set<Product> products;
          
          //접근자, 수정자
      }
      
      public class Product{
          int productid;
          String name;
          int price;
          Category category;
          
          //접근자, 수정자
      }
      ```

      특정 SQL에 대응되게 만든 MAP 오브젝트와 달리 어플리 케이션 어디도 사용될 수 있는 일관된 형식의 도메인 정보를 갖고 있는다.

    - 데이터 중심보다 좋은점

      > 애플리케이션 전역에서 사용될 수 있는 일관된 형식의 정보를 담고 있다.
      >
      > 자바언어의 특성을 활용하도록 정보 가공이 가능하다. (ex: 테이블간의 관계를 레퍼런스 변수로 연결 가능 등)
      >
      > 관계들을 유지하면서 정확한 개수의 정보를 가질 수 있다.
      >
      > 매번 달라지는 SQL결과 또는 변경(column 순서 등)시 DAO만 수정해주면 된다.

  - 도메인 오브젝트를 사용하는 코드

    - 오브젝트 중심 방식에서의 코드를보며 장점을 다시한번 느껴보자.

    ```java
    public int calcTotalOfProductPrice(Category cat){
        int sum=0;
        for(product prd : cat.getProducts())
            sum+=prd.getPrice();
        return sum;
    }
    ```

    > 어떤 DAO를 이용하여 어떻게 가져왔는지는 중요치 않다. 도메인만 알면 된다.

    메소드명만 보고도 메소드의 역할을 유추할 수 있다.

    로직 변경시 코드 수정도 수월하다.

    코드 중복 또한 줄일 수 있다.

    데이터 중심 방식에서는 쉽지 않다.

  - 도메인 오브젝트 사용의 문제점

    - 정보를 오브젝트로 다루면 많은 장점이 있지만, 단점도 있다.
    - 최적화된 SQL을 매번 만들어 사용하는 경우 성능면에서 조금 손해를 볼 수 있다.

    > DAO는 비즈니스 로직을 모르므로 모든 필드 값을 다 채워서 전달하는 경우가 대부분이다. 
    >
    > Product 정보만 필요한 경우에도 Category 오브젝트까지 다 조회될 것이다.
    >
    > 이 경우 DAO에서 구분해 줄 수 있지만, 비즈니스 로직 코드 작성 중 예상치 못한 NullPOinterException의 위험이 있다.
    >
    > 이런 문제를 해결하기 위해 결국 DAO에서 비즈니스 로직을 알고 있어야 하는데, 이는 결국 결합도가 높아지는 문제가 발생한다.

    - 지연된 로딩(lazy loading) 

      - 위의 발생한 문제를 해결하기 위한 방법중 하나

      > 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 정적으로 읽어오게 작성 (약하긴 하지만 계층 사이의 결합이 발생)

    - 가장 이상적인 방법은 ORM기술 (JPA, JDO, 하이버네이트 등)을 이용하는 것이다.

    > 복잡한 DAO코드를 만들지 않아도 되며, 기본적으로 지연된 로딩 기법 등을 제공하여 코드의 양도 대폭 줄일 수 있다. 다양한 기법을 이용하면 성능 또한 향상 시킬 수 있다.

  

  ```
  도메인 오브젝트는 자바오브젝트이다. 오브젝트는 데이터를 저장하기 위해서만 사용하는 것이 아니므로. 내부의 정보를 이용하는 기능도 함께 갖고 있어야 한다. 필드와 그에 대한 접근자, 수정자만 갖고 있는 오브젝트는 반쪽짜리이며 이런 오브젝트를 빈약한 오브젝트라고 부른다.
  ```

  - 빈약한 도메인 오브젝트 방식

    - 가장 흔한 방식이며 데이터를 저장해두는 역할을 한다.
    - 빈약한 오브젝트 방식의 구조는 데이터 중심 아키텍처의 거대 서비스 계층 구조와 유사

    ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.3_AnemicDomainObject.PNG)

    - 로직 재사용성이 다소 낮고 중복의 문제가 있을 수 있지만 유용한 아키텍처이다.

  - 풍성한 도메인 오브젝트 방식

  - 또는 영리한 도메인 오브젝트라고 불린다.
  - 빈약한 도메인 오브젝트의 단점을 극복하고 객체지향적 특징을 잘 사용하도록 개선한 것.
  - 특정 도메인 오브젝트의 정보와 깊은 관계가 있는 로직을 도메인 오브젝트에 넣는 것
  - 이전 서비스 계층에서 만들었던 calcTotalOfProductPrice()를 Category 클래스에 구현

  ```java
    public class Category{
        //...
        List<Product> products;
        
        public int calcTotalOfProductPrice(){
            int sum=0;
            for(product prd : this.products())
                sum+=prd.getPrice();
            return sum;
        }    
    }
  ```

    ​	응집도가 높아졌다.!  :thumbsup:

  - 도메인 오브젝트는 스프링이 관리하는 빈이 아니다.

    ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.3_RichDomainObject.PNG)

    ​	3계층의 오브젝트들은 도메인 오브젝트를 자유롭게 이요할 수 있지만 반대는 안된다.

    ​	:arrow_right:DB에 저장하거나 DB를 검색하는 작업은 불가능하다.

  - 도메인 계층 방식

    - 도메인 오브젝트의 정보가 다시 DB등에 반영 되게 할 수 없는 단점을 극복하기 위해 등장

    - 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 방식

    - 도메인 오브젝트가 독립된 계층을 이루기 때문에 두가지 특징이 있다.

      1. 도메인 종속적 비즈니스 로직의 처리는 서비스 계층이 아닌 도메인 계층의 오브젝트 안에서 진행된다.
      2. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층을 직접 활용할 수 있다.

      > 도메인 오브젝트는 스프링이 관리하는 빈이 아니기 때문에 다른 빈을 DI받을 수 없지만, 간단한 설정을 통해 DI를 적용할 수 있다.
      >
      > 스프링 AOP대신 AspectJ AOP를 이용하면 된다. (Vol.2 Ch5 에서 다룬다)

    - 도메인 오브젝트를 독립적인 계층으로 격상시 도메인 오브젝트가 도메인 계층이 아닌 다른 계층에서도 사용할 수 있게 해야 하는가? 두가지 방법을 선택할 수 있다.

      1. 모든 계층에서 도메인 오브젝트를 사용한다.

      > 간편한 방법이지만, 심각한 혼란을 초래할 수 있다.
      >
      > 철저한 개발 가이드라인을 잡고 강력하게 적용하는 것이다.
      >
      > 어기는 개발자를 위해 AspectJ의 정책/표준 강제화 기능을 사용하면 된다.

      2. 도메인 오브젝트는 도메인 계층에서만 사용한다.

      > 도메인 오브젝트의 내용을 복사해서 넘겨줘야하며, 이때 사용되는 오브젝트를 DTO라고 한다.
      >
      > DTO는 기능을 갖지 않으므로 안전하다.

    - 도메인 계층 방식 구조

    ![](https://studyteamthree.github.io/SpringStudy/assets/img/9.3.3_DomainLayerWay.PNG)

    > 도메인 계층은 싱글톤으로 존재하는 다른 계층과 달리 짧은 시간 존재했다가 사라진다.
    >
    > DI를 등록해 주는 방법 또한 특별해서 다른 3계층의 빈들과 협력해서 일을 처리할수 없다.
    >
    > 여러가지 제약과 불편에도 불구하고 이 방식을 택해야 하는 경우는 매우 복잡하고 변경이 잦은 도메인을 가졌을때다.
    >
    > 응집도가 매우 높아 단위 테스트 작성이 유리하고, 도메인의 복잡함을 가장 유연하게 대응할 수 있다.
    >
    > 반면 그다지 복잡하지 않은 애플리케이션의 경우 부담스러운 방법일 수 있다.

  - DTO와 리포트 쿼리

    - DTO 도메인 계층의 정보 전달을 목적 외에도 사용할 때가 있으며, 그중 대표적 예가 리포트 쿼리라 불리는 DB 쿼리의 실행 결과를 담는 결과이다.
    - DB의 쿼리 하나를 최종 결과를 만들기 힘들 때문에 DTO나 맵, 컬렉션으에 담겨서 전달될 수 있다.

  #### 9.3.4 스프링 애플리케이션을 위한 아키텍처 설정

  ```
  실제로 아키텍처를 설계하는 것에는 다양한 기술과 업무조건 및 이나 환경 등 많은 결정 요소와 변수가 있다. 구체적인 기술의 종류와 세세한 기술적인 조건을 결정해보자
  ```

  - 계층형 아키텍처

    - 스프링 엔터프라이즈 애플리케이션에서 3계층 구조를 가장 많이 사용하지만 절대적이진 않다.
    - 비즈니스 로직이 단순한 애플리케이션의 경우 계층을 통합하는 방법도 있다.
    - 프레젠테이션 계층은 MVC라는 아키텍처를 주로 사용한다. (Vol 2. 3장과 4장에서 다룸) 이때 컨트롤러 부분을 다시 세분화 하기도 한다.
    - 프레젠테이션 계층을 클라이언트까지 확장하기도 한다. SOFEA라고 불리는 아키텍처가 유명하다.
    - :fire:하지만:fire: 우리는 비기너 이므로 전통적인 서버 기반의 3계층 구조에 익숙해지고 프레젠테이션 계층을 SpringMVC로 구현하면서 트랜잭션 AOP를 적용하고, 데이터 액세스 계층은 JDBC및 JPA등을 사용하는 것이다.
    - 아키텍처의 통합과 분산같은 커스텀은 전통적 구조에 익숙해진 다음이다.

  - 정보 전송 아키텍처

    - 빈약한 도메인 오브젝트로 시작하자. (우리는 비기너니깐! :baby::beginner:)
    - 자신감을 얻게되면 점차 도메인 계층에 스프링의 고급기술을 활용해 DI를 적용해보자, 이 과정에서 여러가지 고려할 점이 많을 것이다.

  - 상태 관리와 빈 스코프

    - 아키텍처 설계시 상태 관리 또한 신경써야한다.
    - stateless의 특징을 갖고 있지만 유지되어야 할 작업정보가 있다 (로그인 세션 관리 등)
    - Client URL, 파라미터, hidden form, 쿠키 등의 방법이 있다.
    - 상태를 저장하고 유지하는 방식을 결정하는 것 또한 매우 중요하며 고급 상태 관리 기법을 적용할 수도 있다.

  - 서드파티 프레임워크 라이브러리 적용

    - 스프링은 거의 대부분의 자바 표준 기술과 함께 사용될 수 있다.
    - 또한 오픈소스 프레임워크, 라이브러리, 상용 제품도 함께 사용 할 수 있다.
    - 스프링이 지원하는 기술들을 사용해보자

    ```
    스프링이 지원하는 기술이란 ?
    대표적으로 iBatis, EclipseLink, OpenJPA, WebWork 등 매우 많다. 조건은 다음과 같다.
    1. 해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있다.
       - 빈으로 등록할수 있게 지원해 주는 것들
    2. 스프링의 서비스 추상화가 적용 됐다.
       - 트랜잭션이나 OXM의 예에서 처럼 일관된 접근 방법에 따르는 것이다.
    3. 스프링이 지지하는 프로그래밍 모델을 적용 했다.
       - 대표적으로 일관된 예외 적용이다. 런타임 위주의 예외를 사용한다는 철학을 적용하여 비즈니스 로직의 코드가 액세스 계층의 기술에 종속되지 않는다.
    4. 템플릿/콜백이 지원된다.
       - 스프링은 템플릿/콜백 기능을 제공하여 빈에서 DI 받아 사용한다.
    ```

    - 스프링이 어떤 기술을 지원한다는 것은 스프링이 지지하는 철학을 따른다는 뜻이며 이를 이용해 일관된 구조의 유연하고 확장 가능한 코드를 만들 수 있다.
    - 스프링이 모든 기술을 지원하지 않는 기술을 사용할 때에도 앞서 소개한 네가지를 참고하여 스프링의 철학을 최대한 따르는 것을 추천한다. (스프링이 지원하지 않는다고 스프링의 철학을 무시하며 코드 전체의 틀을 깨버리는 행위는 부끄러운 짓이랍니다.! :rage::worried:)
    - [스프링익스텐션](<https://github.com/spring-projects/spring-integration-extensions>)은 스프링이 직접 지원하지 않지만 나름 유용한 기술들을 스프링 스타일의 지원 기능을 만들어준 것이다. 참고해보자

  

## 정리

- 스프링으로 애플리케이션 프로젝트를 만들면서 초기에 결정해야 할 내용에 대해 살펴보았다.

> - 스프링은 자바 엔터프라이즈에 최적화 되어있다.
> - SpringIDE 플러그인이나 STS같은 적절한 툴의 지원을 받는 것이 좋다.
> - 스프링은 의존 라이브러리가 방대하므로 Maven 이나 Ivy같은 빌드 툴을 이용하여 의존 라이브러리를 관리해야 한다.
> - 스프링 애플리케이션은 보통 역할에 따라 3계층으로 구분되고, 다시 기술의 추상도에 따라 세분화 되는 계층형 아키텍처를 사용하는 것이 좋다.
> - 아키텍처는 애플리케이션이 다루는 정보의 관점에서 데이터 중심과 오브젝트 중심으로 구분할 수 있다.
> - 스프링은 오브젝트 중심 아키텍처가 정말 잘 어울린다.
> - 스프링이 직접 지원하지 않는 서드파티 기술들도 스프링 스타일의 접근 방식을 따라 사용할 필요가 있다.
