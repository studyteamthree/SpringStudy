# 6장 AOP
🍀

## 6.5 스프링 AOP
### 목표
🚩 분리해 낸 코드를 *투명한 부가기능* 형태로 제공하자.
> 다른 코드에서는 그 존재가 보이지 않지만, 메소드가 호출되는 과정에 다이내믹하게 참여해서 부가적인 기능을 제공

<br>

### 6.5.1 자동 프록시 생성
> 😔 프록시 팩토리 빈 방식의 접근 방법의 한계

**1. 부가기능이 타깃 오브젝트마다 새로 만들어지는 문제**
- ProxyFactoryBean 어드바이스를 통해 해결

**2. 부가기능의 적용이 필요한 타겟 오브젝트마다 비슷한 내용의 ProxyFactoryBean 빈 설정 정보를 추가해주는 문제**

<br>

#### 중복 문제의 접근 방법
1. 전략 패턴과 DI 적용
   - 다이나믹 프록시 생성 팩토리에 DI로 제공
   - **변하는 부가기능 코드**

2. 다이나믹 프록시
   - 코드 자동 생성 기법 사용
   - **변하지 않는 타겟으로의 위임과 부가기능 적용 여부 판단하는 부분**

❓ *반복적인 ProxyFactoryBean 설정 문제를 해결하는 방법은 없을까?*

<br>

#### 빈 후처리기를 이용한 자동 프록시 생성기
> 스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 **확장 포인트를 제공** 해 준다.

➡️ 스프링 빈 오브젝트로 만들어지고 난 후, 다시 빈 오브젝트를 가공할 수 있게 해주는 **빈 후처리기** 를 사용해보자.

❔ 빈 후처리기 적용 방법

❕ 빈 후처리기 자체를 빈으로 등록한다. 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다. 후처리 작업을 통해 스프링이 설정을 참고해서 만든 오브젝트가 아닌 다른 오브젝트를 빈으로 등록시키는 것이 가능하다.  
이를 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수 있다. (**자동 프록시 생성 빈 후처리기**)

##### DefaultAdvisorAutoProxyCreator
- 빈 후처리기 중 하나
- 어드바이저를 이용한 자동 프록시 생성기

![빈 후처리기를 이용한 프록시 자동생성](../assets/img/6-20.png)
1. DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에 빈을 보낸다.
2. DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 **어드바이저 내의 *포인트컷*** 을 이용해 전달받은 빈이 **프록시 적용 대상인지 확인** 한다.
3. 프록시 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, **만들어진 프록시에 어드바이저를 연결** 해준다.
4. 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 **프록시 오브젝트를 컨테이너에게 돌려준다**.
5. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.

<br>

#### 확장된 포인트컷
❗️ 포인트컷은 **타겟 오브젝트의 메소드 중에서 어떤 메소드에 부가기능을 적용할지 선정** 해주거나 **등록된 빈 중에서 어떤 빈에 프록시를 적용할 지 선택** 해주는 기능을 모두 갖고 있다.

```java
public interface Pointcut {
  ClassFilter getClassFilter(); // 프록시를 적용할 클래스인지 확인해준다.
  MethodMatcher getMethodMatcher(); // 어드바이스를 적용할 메소드인지 확인해준다.
}
```

만약 Pointcut 선정 기능을 모두 적용한다면 먼저 1️⃣ 프록시를 적용할 클래스인지 판단한 후, 적용 대상 클래스인 경우에는 2️⃣ 어드바이스를 적용할 메소드인지 확인하는 식으로 동작한다.

➡️ 모든 빈에 대해 프록시 자동 적용 대상을 선별해야 하는 빈 후처리기인 DefaultAdvisorAutoProxyCreator는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트컷과 어드바이스가 결합되어 있는 어드바이저가 등록되어 있어야 한다.


<br>

#### 포인트컷 테스트
기존 구현한 예제 코드에서 클래스를 고를 수 있도록 고치고, 프록시 적용 후보 클래스를 여러 개 만들어둔 후 포인트컷을 적용한 ProxyFactoryBean으로 프록시를 만들도록 해서 어드바이스가 적용되는지 확인해보자.

480 페이지의 에제 코드를 보면, classNamePointcutAdvisor에서 클래스 이름이 HelloT로 시작하는 클래스만 선정하도록 수정하였고, 여러 케이스에 대해 적용 대상인지 확인한 후 메소드 선정 방식을 통해 어드바이스를 적용시키는 것을 확인할 수 있다.

⚠️ 포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면 아무리 프록시를 적용했다고 해도 부가기능은 전혀 제공되지 않는다는 점에 주의하자.

<br>
<br>

### 6.5.2 DefaultAdvisorAutoProxyCreator의 적용
#### 클래스 필터를 적용한 포인트컷 작성
메소드 이름만 비교하던 포인트컷인 NameMatchMethodPointcut을 상속해서 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름을 비교하는 ClassFilter를 추가시킨다. (482p 6-51)

<br>

#### 어드바이저를 이용하는 자동 프록시 생성기 등록
어드바이저를 이용하는 자동 프록시 생성기를 등록하기 위해 DefaultAdvisorAutoProxyCreator 빈을 등록한다.

<br>

#### 포인트컷 등록
클래스 필터 지원 포인트컷을 빈으로 등록한다.

<br>

#### 어드바이스와 어드바이저
어드바이스 빈의 설정은 수정할 게 없지만, 어드바이저로서 사용되는 방법이 바뀌었다. 이제는 **명시적으로 DI하지 않는** 대신, *어드바이저를 이용하는 자동 프록시 생성기에 의해 자동수집되고, 프록시 대상 선정 과정에 참여하며, 자동생성된 프록시에 다이나믹하게 DI되어 동작* 하는 어드바이저가 된다.

<br>

#### ProxyFactoryBean 제거와 서비스 빈의 원상복구
더 이상 명시적인 프록시 팩토리 빈을 등록하지 않기 때문에 프록시를 적용하기 전의 단순한 상태로 돌려놓는다.

<br>

#### 자동 프록시 생성기를 사용하는 테스트
기존 테스트 코드는 ProxyFactoryBean이 빈으로 등록되어 있었으므로 이를 가져와 타겟을 테스트용 클래스로 바꿔치기하는 방법을 사용했지만, 자동 프록시 생성기를 적용한 후에는 가져올 팩토리 빈이 없기 때문에 다른 방법을 사용해야 한다.

❓ 그렇다면 어떻게 테스트 해야 할까?

❗️ 자동 프록시 생성기라는 스프링 컨테이너에 종속적인 기법을 사용했기 때문에 예외상황을 위한 테스트 대상도 빈으로 등록해줘야 한다.

예제 코드를 기준으로 테스트 클래스를 직접 빈으로 등록했을 때 문제점이 발생하는 부분이 있고, 485~486 페이지는 발생한 문제점들을 해결하는 과정이다.

> 📘 XML에서 빈을 등록할 때, 스태틱 멤버 클래스를 지정하고 싶다면 '$'를 사용하면 되고, parent 애트리뷰트를 이용하면 다른 빈 설정의 내용을 상속받을 수 있다.

테스트 코드 작성이 완료되었다면 테스트를 실행해본다.

**자동 프록시 생성기가 평범한 비즈니스 로직만 담고 있는 빈을 자동으로 트랜잭션 부가기능을 제공해주는 프록시로 대체했는지** 확인해보자.

<br>

#### 자동생성 프록시 확인
> 지금까지 트랜잭션 어드바이스를 적용한 프록시 자동생성기를 빈 후처리기 메커니즘을 통해 적용하였다. 확인해야 할 사항은 다음과 같다.

1. 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용되었는가?
   - 예외 상황에서 트랜잭션이 롤백되게 함으로써 트랜잭션 적용 여부를 테스트한다.

2. 프록시 자동생성기가 어드바이저 빈에 연결해둔 포인트컷의 클래스 필터를 이용해서 정확히 원하는 빈에만 프록시를 생성하였는가?
   - 전부 확인하기는 어려우므로 클래스 필터가 제대로 동작하는지 확인한다.

<br>
<br>

### 6.5.3 포인트컷 표현식을 이용한 포인트컷
**메소드 이름과 클래스의 이름 패턴을 각각 클래스 필터와 메소드 매처 오브젝트로 비교해서 선정하는 방식**

😔 일일이 클래스 필터와 메소드 매처를 구현하거나, 스프링이 제공하는 필터나 매처 클래스를 가져와 프로퍼티를 설정해야 한다.  
😔 단순히 이름을 비교하는 기능밖에 하지 못한다.

> ❔ 더 복잡하고 세밀한 기준을 이용해 클래스나 메소드를 선정하게 하려면?

**1. 리플렉션 API**  
클래스와 메소드의 이름, 정의된 패키지 등 여러 정보를 알아낼 수 있지만, 작성하기가 번거롭다.

**2. 포인트컷 표현식(pointcut expression)**
- AspectJExpressionPointcut 클래스 사용하여 적용

<br>

#### AspectJExpressionPointcut
- 클래스와 메소드의 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있게 해준다.
- 포인트컷 표현식은 자바의 RegEx클래스가 지원하는 정규식처럼 강력한 표현식을 지원한다.
- AspectJ 프레임워크에서 제공하는 것을 가져와 확장해서 사용하므로, **AspectJ 포인트컷 표현식** 이라고도 한다.

<br>

#### 포인트컷 표현식 문법
AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다. 지시자 중 execution()이 가장 대표적으로 사용된다.

`execution(1️⃣[접근제한자 패턴] 2️⃣타입패턴 3️⃣[타입패턴.]4️⃣이름패턴 5️⃣(타입패턴 | *..*, ...)) 6️⃣[throws 예외 패턴]`

1️⃣ public, private과 같은 접근제한자. 생략 가능  
2️⃣ 리턴 값의 타입 패턴. 필수항목으로, 반드시 하나의 타입을 지정해야 한다.  
3️⃣ 패키지와 클래스 이름에 대한 패턴. 생략 가능하며, 사용할 때는 '.'을 두어서 연결해야 한다.  
4️⃣ 메소드 이름 패턴. 필수항목이다.  
5️⃣ 파라미터의 타입 패턴을 순서대로 넣을 수 있다. 와일드카드를 이용해 파라미터 개수에 상관 없는 패턴을 만들 수 있다. 필수 항목이다.  
6️⃣ 예외 이름 패턴. 생략 가능

(생략 가능한 항목을 생략했을 경우, 모든 경우를 다 허용하여 느슨한 포인트컷이 된다는 점에 주의하자)

메소드 시그니처를 이용한 포인트컷 표현식 테스트는 492페이지의 코드 예제에 잘 나타나 있다. pointcut에 표현식을 지정하고, 그 표현식으로 메소드 매처와 클래스 필터에서 잘 동작하는 것을 확인할 수 있다.

포인트컷 표현식 | 설명
--- | ---
* | 리턴 값의 타입에 대한 제한을 없애고 어떤 리턴 타입을 가졌던 상관없이 선정하도록 만든다.
(..) | 파라미터의 개수와 타입을 무시한다.

![AspectJ 포인트컷 표현식의 메소드 선정 결과](../assets/img/table6-1.png)

<br>

#### 포인트컷 표현식을 이용하는 포인트컷 적용
AspectJ 포인트컷 표현식은 메소드의 시그니처를 비교하는 방식인 execution() 외에도 몇 가지 표현식 스타일을 갖고 있다.
- 빈의 이름으로 비교하는 bean()
- 특정 애노테이션이 타입, 메소드, 파라미터에 적용되어 있는 것을 보고 메소드를 선정하게 하는 포인트컷

이전에 ProxyFactoryBean을 적용했던 코드에 AspectJExpressionPointcut 빈을 등록하고, 표현식을 적용시키는 내용이 498~499 페이지에 나와있다.

<br>

#### 타입 패턴과 클래스 이름 패턴
타입 패턴 | 클래스 패턴
--- | ---
포인트컷 표현식에서 사용 |
**슈퍼클래스, 인터페이스 등을 따져 타입 패턴의 조건에 충족하는 빈은 모두 선정한다.** | 단순하게 이름이 매치되면 선정한다.

포인트컷 표현식에서 타입 패턴이라고 명시된 부분은 모두 동일한 원리가 적용된다.

<br>
<br>

### 6.5.4 AOP란 무엇인가?
예제 코드를 작성해 온 과정을 되짚어본다.
#### 트랜잭션 서비스 추상화
트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣으려니 특정 트랜잭션 기술에 종속되는 코드가 되어버리는 문제가 발생하였다.

❗️ 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법 적용  
➡️ 인터페이스와 DI를 통해 무엇을 하는지는 남기고, 그것을 어떻게 하는지를 분리하였다.

<br>

#### 프록시와 데코레이터 패턴


<br>

#### 다이내믹 프록시와 프록시 팩토리 빈


<br>

#### 자동 프록시 생성 방법과 포인트컷


<br>
